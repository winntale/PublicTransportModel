#pragma once


using namespace System;
using namespace System::Drawing;
using namespace System::Windows::Forms;
using namespace System::Collections::Generic;

#include "Defines.h"
#include "passengerClass.h"


// класс, используемый для поиска пути
public ref class Node {
public:
	int vertice;
	Node^ previous;
	String^ direction; // направление, куда двигались, чтобы попасть из previous в текущую ноду

	Node(int _vertice) {
		vertice = _vertice;
		previous = nullptr;
		direction = "";
	}
	~Node() {}
};

public ref class TaxiCar {
private:
	int _xPos;
	int _yPos;

	int _maxVelocity;
	System::String^ _direction;
	System::String^ _color;
	int _fuelWaste;
	int _currentFuel;
	int _state; // 0 - ожидание; 1 - выполнение заказа; 2 - низкий уровень топлива

	// поля для 2-ой точки
	Point^ _nextPoint;
	int _npCrossroadIndex;
	int _npVerticeIndex;

	// поля для 3-ей точки
	Point^ _nextPoint2;
	int _npCrossroadIndex2;
	int _npVerticeIndex2;
	List<Node^>^ _way;

public:
	TaxiCar() {
		_xPos = 0;
		_yPos = 0;

		_fuelWaste = 1;
		_currentFuel = 100;
		_state = 0;

		_way = gcnew List<Node^>(0);
	}
	~TaxiCar() {};

	property int maxVelocity {
		int get() { return _maxVelocity; }
		void set(int _value) {
			if (_value < 50) { _maxVelocity = 50; }
			else if (_value > 200) { _maxVelocity = 200; }
			else { _maxVelocity = _value; }
		};
	};

	property System::String^ direction {
		System::String^ get() { return _direction; }
		void set(System::String^ _value) { _direction = _value; }
	};

	property int xPos {
		int get() { return _xPos; }
		void set(int _value) { _xPos = _value; }
	}

	property int yPos {
		int get() { return _yPos; }
		void set(int _value) { _yPos = _value; }
	}

	property System::String^ color {
		System::String^ get() { return _color; }
		void set(System::String^ _value) {
			if (System::String::IsNullOrEmpty(_value)) {
				MessageBox::Show("Вы не указали цвет машины такси", "Ошибка",
					MessageBoxButtons::OK, MessageBoxIcon::Error);
			}
			else { _color = _value; }
		}
	};

	property int fuelWaste {
		int get() { return _fuelWaste; }
	};

	property int currentFuel {
		int get() { return _currentFuel; }
		void set(int _value) { _currentFuel = _value; }
	};

	property int state {
		int get() { return _state; }
		void set(int _value) { _state = _value; }
	};

	property Point^ nextPoint {
		Point^ get() { return _nextPoint; }
		void set(Point^ _value) { _nextPoint = _value; }
	}

	property int npCrossroadIndex {
		int get() { return _npCrossroadIndex; }
		void set(int _value) { _npCrossroadIndex = _value; }
	}

	property int npVerticeIndex {
		int get() { return _npVerticeIndex; }
		void set(int _value) { _npVerticeIndex = _value; }
	}

	property Point^ nextPoint2 {
		Point^ get() { return _nextPoint2; }
		void set(Point^ _value) { _nextPoint2 = _value; }
	}

	property int npCrossroadIndex2 {
		int get() { return _npCrossroadIndex2; }
		void set(int _value) { _npCrossroadIndex2 = _value; }
	}

	property int npVerticeIndex2 {
		int get() { return _npVerticeIndex2; }
		void set(int _value) { _npVerticeIndex2 = _value; }
	}

	property List<Node^>^ way {
		List<Node^>^ get() { return _way; }
	}

	// метод описания движения и поворота в 0 состоянии машины (завершён)
	void Move(array<array<Point^>^>^ Vertices) {
		// в зависимости от направления (direction) меняются координаты x, y
		if (_direction == "left") { _xPos -= SPEED; }
		else if (_direction == "right") { _xPos += SPEED; }

		else if (_direction == "down") { _yPos += SPEED; }
		else if (_direction == "up") { _yPos -= SPEED; }


		Random^ rndGen = gcnew Random();

		bool isTurned = false;
		String^ _direction2 = _direction;


		// рассмотрим 2 ситуации: 1) машина движется по Y	2) машина движется по X
		// машина достигла Y (двигалась по вертикали)
		if (_direction == "up" || _direction == "down") {
			if ((Math::Abs(_yPos - (_nextPoint->Y - (TAXICAR_IMG_HEIGHT / 2))) < SPEED) && !isTurned) {
				_yPos = _nextPoint->Y - (TAXICAR_IMG_HEIGHT / 2); // корректировка Y

				bool a = (Vertices[_npCrossroadIndex][_npVerticeIndex]->X == Vertices[_npCrossroadIndex2][_npVerticeIndex2]->X); // совпал X у 1-й и 2-й точки
				bool b = (Vertices[_npCrossroadIndex][_npVerticeIndex]->Y == Vertices[_npCrossroadIndex2][_npVerticeIndex2]->Y); // совпал Y у 1-й и 2-й точки

				// (2) -> (1) (то есть (2) становится startPoint'ом)
				int crossroadIndex1 = _npCrossroadIndex;
				int verticeIndex1 = _npVerticeIndex;

				// (3) -> (2) (то есть (3) становится nextPoint'ом)
				_nextPoint = _nextPoint2;
				_npCrossroadIndex = _npCrossroadIndex2;
				_npVerticeIndex = _npVerticeIndex2;

				// задаём горизонтальное движение до текущей (2)
				if (_npCrossroadIndex > crossroadIndex1) { _direction2 = "right"; } // направо
				else if (_npCrossroadIndex < crossroadIndex1) { _direction2 = "left"; } // налево

				// (*) -> (3). создание новой точки, которая станет nextPoint2'ом
				// 1) генерируем перекрёсток (*), пока не достигнем горизонтального движения
				while (b || !a || (_npCrossroadIndex == _npCrossroadIndex2)) {
					_npCrossroadIndex2 = rndGen->Next(0, VERTEX_QUANTITY);

					for (int i = 0; i < 4; i++) {
						a = (Vertices[_npCrossroadIndex][_npVerticeIndex]->X == Vertices[_npCrossroadIndex2][i]->X);
						b = (Vertices[_npCrossroadIndex][_npVerticeIndex]->Y == Vertices[_npCrossroadIndex2][i]->Y);
						if (!b && a && (_npCrossroadIndex != _npCrossroadIndex2)) { break; }
					}
				}
				if (_npCrossroadIndex2 > _npCrossroadIndex) {
					_npVerticeIndex = Convert::ToInt16(verticeIndex1 / 2) * 2;
					_npVerticeIndex2 = 2 * rndGen->Next(0, 2);
				}
				else if (_npCrossroadIndex2 < _npCrossroadIndex) {
					_npVerticeIndex = Convert::ToInt16(verticeIndex1 / 2) * 2 + 1;
					_npVerticeIndex2 = 2 * rndGen->Next(0, 2) + 1;
				}


				_nextPoint = Vertices[_npCrossroadIndex][_npVerticeIndex];
				_nextPoint2 = Vertices[_npCrossroadIndex2][_npVerticeIndex2];

				isTurned = true;
			}
		}
		// машина достигла X (двигалась по горизонтали)
		else if (_direction == "right" || _direction == "left") {
			if ((Math::Abs(_xPos - (_nextPoint->X - (TAXICAR_IMG_HEIGHT / 2))) < SPEED) && !isTurned) {
				_xPos = _nextPoint->X - (TAXICAR_IMG_HEIGHT / 2); // корректировка X

				bool a = (Vertices[_npCrossroadIndex][_npVerticeIndex]->X == Vertices[_npCrossroadIndex2][_npVerticeIndex2]->X); // совпал X у 1-й и 2-й точки
				bool b = (Vertices[_npCrossroadIndex][_npVerticeIndex]->Y == Vertices[_npCrossroadIndex2][_npVerticeIndex2]->Y); // совпал Y у 1-й и 2-й точки

				// (2) -> (1) (то есть (2) становится startPoint'ом)
				int crossroadIndex1 = _npCrossroadIndex;
				int verticeIndex1 = _npVerticeIndex;

				// (3) -> (2) (то есть (3) становится nextPoint'ом)
				_nextPoint = _nextPoint2;
				_npCrossroadIndex = _npCrossroadIndex2;
				_npVerticeIndex = _npVerticeIndex2;

				// задаём вертикальное движение до текущей (2)
				if (_npCrossroadIndex > crossroadIndex1) { _direction2 = "down"; } // вниз
				else if (_npCrossroadIndex < crossroadIndex1) { _direction2 = "up"; } // вверх

				while (a || !b || (_npCrossroadIndex == _npCrossroadIndex2)) {
					_npCrossroadIndex2 = rndGen->Next(0, VERTEX_QUANTITY);

					for (int i = 0; i < 4; i++) {
						a = (Vertices[_npCrossroadIndex][_npVerticeIndex]->X == Vertices[_npCrossroadIndex2][i]->X);
						b = (Vertices[_npCrossroadIndex][_npVerticeIndex]->Y == Vertices[_npCrossroadIndex2][i]->Y);
						if (!a && b && (_npCrossroadIndex != _npCrossroadIndex2)) { break; }
					}
				}

				if (_npCrossroadIndex2 > _npCrossroadIndex) {
					_npVerticeIndex = (verticeIndex1 % 2) + 2;
					_npVerticeIndex2 = rndGen->Next(2, 4);
				}
				else if (_npCrossroadIndex2 < _npCrossroadIndex) {
					_npVerticeIndex = (verticeIndex1 % 2);
					_npVerticeIndex2 = rndGen->Next(0, 2);
				}

				_nextPoint = Vertices[_npCrossroadIndex][_npVerticeIndex];
				_nextPoint2 = Vertices[_npCrossroadIndex2][_npVerticeIndex2];

				isTurned = true;
			}
		}

		if (isTurned) {
			_direction = _direction2;
			isTurned = false;
		}
	}


	// метод поиска пути

	bool IsContainsVertice(List<Node^>^ Nodes, Node^ newNode) {
		bool flag = false;
		for each (Node^ node in Nodes)
			if (node->vertice == newNode->vertice) {
				flag = true;
				break;
			}
		return flag;
	}

	int IndexOfVertice(List<Node^>^ Nodes, Node^ newNode) {
		int index = -1;
		for each (Node^ node in Nodes)
			if (node->vertice == newNode->vertice) {
				index = Nodes->IndexOf(node);
				break;
			}
		return index;
	}

	List<Node^>^ BuildPath(Node^ passNode) {
		List<Node^>^ path = gcnew List<Node^>(0);

		while (passNode != nullptr) {
			path->Add(passNode);
			passNode = passNode->previous;
		}
		return path;
	}

	void CrossroadRemover(List<Node^>^ newReachable, int currentNodeCrossroad, bool flag) {
		// если флаг в положении true, то оставляем только перекрёстки с индексами больше, чем текущий
		if (flag) {
			for each (Node^ availableNode in newReachable->ToArray()) {
				int availableCrossroad = availableNode->vertice / 10;

				if (availableCrossroad <= currentNodeCrossroad)
					newReachable->Remove(availableNode);
			}
		}
		else {
			for each (Node^ availableNode in newReachable->ToArray()) {
				int availableCrossroad = availableNode->vertice / 10;

				if (availableCrossroad >= currentNodeCrossroad)
					newReachable->Remove(availableNode);
			}
		}
	}

	bool IsEqualsCrossroads(List<Node^>^ newReachable, int vertice) {
		bool flag = false;
		for each (Node^ availableNode in newReachable) {
			if ((availableNode->vertice / 10) == (vertice / 10)) {
				flag = true;
				break;
			}
		}
		return flag;
	}

	void WayFind(Passenger^ passenger, array<array<Point^>^>^ Vertices, Label^ label) {
		Random^ rndGen = gcnew Random();

		// создаём массив нод, которые сейчас можно рассмотреть и массив точек, в которых мы уже были
		List<Node^>^ reachable = gcnew List<Node^>(0);
		List<int>^ explored = gcnew List<int>(0);

		// за начальную точку возьмём индексы точки, в которую на данный момент едет машина
		int startIndexes = _npCrossroadIndex * 10 + _npVerticeIndex;
		Node^ startNode = gcnew Node(startIndexes);

		// добавляем в массив допустимых нод стартовую ноду
		reachable->Add(startNode);

		// то же самое с точкой, которая представляет из себя начальную точку линии, где находится пассажир
		int passIndexes = passenger->startCrossroadIndex::get() * 10 + passenger->startVerticeIndex::get();
		Node^ passNode = gcnew Node(passIndexes);

		bool a = false;
		bool b = false;

		// цикл будет работать, пока есть точки, которые можно рассмотреть
		while (reachable->Count > 0) {
			// задаём текущую точку (берём её случайно из массива доступных точек)
			Node^ currentNode = reachable[rndGen->Next(0, reachable->Count)];
			int currentNodeCrossroad = currentNode->vertice / 10;
			int currentNodeVertice = currentNode->vertice % 10;

			// условие выхода осуществляется, если мы взяли точку, которая соответствует началу линии, где находится пассажир
			if (currentNode->vertice == passNode->vertice) {
				_way = BuildPath(passNode);
				for (int i = 0; i < _way->Count; i++) {
					label->Text += Convert::ToString(_way[i]->vertice);
				}
				break;
			}
			
			// так как мы взяли текущую точку, то удаляем её из массива доступных и заносим в массив пройденных
			reachable->Remove(currentNode);
			explored->Add(currentNode->vertice);

			// создаём массив точек, которых можно достичь ОТ текущей точки
			List<Node^>^ newReachable = gcnew List<Node^>(0);

			// проходим по всей системе дорог
			for (int i = 0; i < VERTEX_QUANTITY; i++) {
				for (int j = 0; j < 4; j++) {
					// задаём индексы точки, которую сейчас рассматриваем (потенциально следующая точка)
					int nextIndexes = i * 10 + j;
					int nextNodeCrossroad = nextIndexes / 10;
					int nextNodeVertice = nextIndexes % 10;

					
					a = Vertices[currentNodeCrossroad][currentNodeVertice]->X == Vertices[nextNodeCrossroad][nextNodeVertice]->X; // совпал X (вертикальное движение)
					b = Vertices[currentNodeCrossroad][currentNodeVertice]->Y == Vertices[nextNodeCrossroad][nextNodeVertice]->Y; // совпал Y (горизонтальное движение)

					Node^ nextNode = gcnew Node(nextIndexes);
					// если совпала лишь одна координата и мы пока не прошли потенциально следующую точку
					if (((a + b) % 2) && (explored->IndexOf(nextNode->vertice) == -1) && !IsContainsVertice(newReachable, nextNode) && (currentNodeCrossroad != i)) {
						if (currentNodeVertice == 0) {
							if (a && nextNodeCrossroad > currentNodeCrossroad)
								newReachable->Add(nextNode);
							else if (b && nextNodeCrossroad < currentNodeCrossroad)
								newReachable->Add(nextNode);
						}
						else if (currentNodeVertice == 1 && nextNodeCrossroad < currentNodeCrossroad)
							newReachable->Add(nextNode);
						else if (currentNodeVertice == 2 && nextNodeCrossroad > currentNodeCrossroad)
							newReachable->Add(nextNode);
						else if (currentNodeVertice == 3) {
							if (a && nextNodeCrossroad < currentNodeCrossroad)
								newReachable->Add(nextNode);
							else if (b && nextNodeCrossroad > currentNodeCrossroad)
								newReachable->Add(nextNode);
						}
						/*if (a && (nextNodeCrossroad > currentNodeCrossroad)) { nextNode->direction == "down"; }
						else if (a && (nextNodeCrossroad < currentNodeCrossroad)) { nextNode->direction == "up"; }
						
						else if (b && (nextNodeCrossroad > currentNodeCrossroad)) { nextNode->direction == "right"; }
						else { nextNode->direction == "left"; }

						
						if (currentNode->direction == "") { newReachable->Add(nextNode); }
						else if (currentNode->direction == "up" && nextNode->direction != "down") { newReachable->Add(nextNode); }
						else if (currentNode->direction == "down" && nextNode->direction != "up") { newReachable->Add(nextNode); }
						else if (currentNode->direction == "right" && nextNode->direction != "left") { newReachable->Add(nextNode); }
						else if (currentNode->direction == "left" && nextNode->direction != "right") { newReachable->Add(nextNode); }*/

						
						

						// 12 13 30 32 50 52 82 83
						// -> 50 52 82 83



					}
				}
			}

			// рассматриваем каждый элемент массива точек, в которых можно попасть от текущей (current)
			for (int i = 0; i < newReachable->Count; i++) {
				for each (Node^ availableNode in newReachable->ToArray()) {
					// availablePoint - точка, в которую можно поппасть от current (то есть путь current -> available уже существует)
					Point^ availablePoint = Vertices[availableNode->vertice / 10][availableNode->vertice % 10];
					Point^ currentPoint = Vertices[currentNodeCrossroad][currentNodeVertice];
					Point^ comparablePoint = Vertices[newReachable[i]->vertice / 10][newReachable[i]->vertice % 10];

					// если потенциально следующая точка (nextPoint) и точка, в которую можно попасть от current (available) находятся на одной линии
					// и расстояние от current до next меньше, чем расстояние от current до available
					// и перекрёсток nextPoint не равен перекрёсткам availablePoint и currentPoint
					bool sameX = (comparablePoint->X == availablePoint->X); bool sameY = (comparablePoint->Y == availablePoint->Y);
					bool IsnpYCloser = (Math::Abs(comparablePoint->Y - currentPoint->Y) < Math::Abs(availablePoint->Y - currentPoint->Y) - 60);
					bool IsnpXCloser = (Math::Abs(comparablePoint->X - currentPoint->X) < Math::Abs(availablePoint->X - currentPoint->X) - 60);
					if (((sameX && IsnpYCloser) || (sameY && IsnpXCloser)) && (newReachable[i]->vertice / 10 != availableNode->vertice / 10) && (newReachable[i]->vertice / 10 != currentNodeCrossroad)
						&& (newReachable[i]->vertice % 10 == availableNode->vertice % 10))
					{
						newReachable[newReachable->IndexOf(availableNode)] = newReachable[i];
					} // то меняем в массиве доступных точек значение рассматриваемого индекса на nextNode
				}
			}

			for each (Node^ adjacent in newReachable) {
				if (!IsContainsVertice(reachable, adjacent)) {
					adjacent->previous = currentNode;
					reachable->Add(adjacent);
				}
			}
			newReachable = nullptr;
		}






		//// вносим в массив пути начальный перекрёсток пути, соответствующий 3ей точке при генерации, умноженный на 10 (вытащить можно с помощью деления нацело на 10),
		//// а также вершину 3ей точки (вытащить можно с помощью деления по модулю 10 (% 10)).
		//// то есть точка представляет из себя число (1-3значное), например 0ой перекрёсток 3ья вершина - 3, 1ый перекрёсток 2ая вершина - 12, 12ый перекрёсток 1ая вершина - 121.
		//
		//_way->Add((_npCrossroadIndex2 * 10) + _npVerticeIndex2);
		//List<int>^ reachable = gcnew List<int>(2);

		//bool a = false;
		//bool b = false;

		//// нужен метод (событие) подбирания пассажира (совпала одна из координат (вторая координата варьируется по области в зависимости от направления движения)
		//// + едет по той же линии независимо от метода поиска пути)
		//bool finalEqualsPasLineStart = _way[_way->Count - 1] == (passenger->startCrossroadIndex::get() * 10) + passenger->startVerticeIndex::get();
		//bool finalEqualsPasLineEnd = _way[_way->Count - 1] == (passenger->endCrossroadIndex::get() * 10) + passenger->endCrossroadIndex::get();

		//// если индекс начального перекрёстка меньше, чем индекс конечного
		//if (_npCrossroadIndex2 < passenger->startCrossroadIndex::get()) {
		//	while (!finalEqualsPasLineStart) {
		//		// переназначение текущей точки
		//		int currentCrossroad = _way[0] / 10;
		//		int currentVertice = _way[0] % 10;
		//		Point^ currentPoint = Vertices[currentCrossroad][currentVertice];

		//		// verticeIndex = reachable[0] % 10; crossroadIndex = reachable[0] / 10
		//		// verticeIndex = 0 тогда a: i > crossroadIndex, b: i < crossroadIndex
		//		// verticeIndex = 1 тогда a или b: i < crossroadIndex
		//		// verticeIndex = 2 тогда a или b: i > crossroadIndex
		//		// verticeIndex = 3 тогда a: i < crossroadIndex, b: i > crosroadIndex

		//		List<int>^ verticeCompatible = gcnew List<int>(2); // 33, 32, 22, 20
		//		verticeCompatible->Add(33); verticeCompatible->Add(32); verticeCompatible->Add(22); verticeCompatible->Add(20);

		//		// ГЕНЕРАЦИЯ МАССИВА ДОСТИГАЕМЫХ ТОЧЕК ОТ ТЕКУЩЕЙ (vertice)
		//		// в цикле идём по всем перекрёсткам и их вершинам от большего индекса к меньшему
		//		// 
		//		//for (int i = VERTEX_QUANTITY - 1; i >= currentCrossroad; i--) {
		//		//	int nextCrossroad = i;
		//		//	for each (int vertices in verticeCompatible) {
		//		//		if (currentVertice < 2) { nextVertice = (currentVertice % 2) + 2; }
		//		//		int nextVertice = vertices % 10;
		//		//	}
		//		//	if () { break; }

		//		//}


		//		/*if () {
		//			_way[wayLength] = Vertices[reachable[0] / 10][reachable[0] % 10];
		//			label->Text += Convert::ToString(String::Format(" {0}{1}", reachable[0] / 10, reachable[0] % 10));
		//			wayLength++;
		//		}
		//		else {
		//			_way[wayLength] = Vertices[passenger->endCrossroadIndex][passenger->endVerticeIndex];
		//			label->Text += Convert::ToString(_way[wayLength]);
		//			wayLength++;
		//			reachable->RemoveRange(0, reachable->Count);
		//		}*/
		//	}
		//}
	}

	void MoveToPassenger() {
		 // практически аналог move
	}

};